import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { db } from "@/integrations/postgres/client";
import { toast } from "sonner";
import { useNotificationMutations } from "@/hooks/useNotificationMutations";

type Sale = {
  id: string;
  machine_id?: string;
  franchise_id?: string;
  sales_date: string;
  coin_sales: number;
  sales_amount: number;
  prize_out_quantity: number;
  prize_out_cost: number;
  created_at?: string;
};

export function useSales() {
  return useQuery({
    queryKey: ["sales"],
    queryFn: async () => {
      // Fetch sales, machines, franchises, banks, payments, and users separately
      const [sales, machines, franchises, banks, payments, users] = await Promise.all([
        db.from("sales").select("*").order("sales_date", { ascending: false }).execute(),
        db.from("machines").select("*").execute(),
        db.from("franchises").select("*").execute(),
        db.from("banks").select("*").execute(),
        db.from("machine_payments").select("*").execute(),
        db.from("users").select("*").execute()
      ]);

      // Create lookup maps
      const machineMap = new Map();
      machines?.forEach(machine => {
        machineMap.set(machine.id, machine);
      });

      const bankMap = new Map();
      banks?.forEach(bank => {
        bankMap.set(bank.id, bank);
      });

      const franchiseMap = new Map();
      franchises?.forEach(franchise => {
        const franchiseWithBank = {
          ...franchise,
          banks: franchise.payment_bank_id ? bankMap.get(franchise.payment_bank_id) : null
        };
        franchiseMap.set(franchise.id, franchiseWithBank);
      });

      const userMap = new Map();
      users?.forEach(user => {
        userMap.set(user.id, user);
      });

      // Calculate payment totals for each sale by invoice_id or fallback to machine/date
      const paymentMap = new Map();
      payments?.forEach(payment => {
        if (payment.invoice_id) {
          // Use invoice_id as key
          const currentTotal = paymentMap.get(payment.invoice_id) || 0;
          paymentMap.set(payment.invoice_id, currentTotal + (payment.amount || 0));
        } else if (payment.machine_id && payment.payment_date) {
          // Fallback to old logic for legacy payments
          const normalizedDate = new Date(payment.payment_date).toISOString().split('T')[0];
          const key = `${payment.machine_id}_${normalizedDate}`;
          const currentTotal = paymentMap.get(key) || 0;
          paymentMap.set(key, currentTotal + (payment.amount || 0));
        }
      });
      


      // Join sales with machine, franchise, and payment data
      const salesWithDetails = (sales || []).map(sale => {
        const machine = sale.machine_id ? machineMap.get(sale.machine_id) : null;
        const franchise = machine?.franchise_id ? franchiseMap.get(machine.franchise_id) : null;
        
        // Use invoice number from database (auto-generated by trigger)
        const invoiceNumber = sale.invoice_number || 'Pending';
        
        // Match payments by invoice_id first, then fallback to machine/date
        let totalPaid = paymentMap.get(sale.id) || 0;
        if (totalPaid === 0) {
          // Fallback to old matching logic
          const normalizedSalesDate = new Date(sale.sales_date).toISOString().split('T')[0];
          const paymentKey = `${sale.machine_id}_${normalizedSalesDate}`;
          totalPaid = paymentMap.get(paymentKey) || 0;
        }
        
        const payToClowee = sale.pay_to_clowee || 0;
        

        
        // Calculate payment status based on pay_to_clowee amount
        let paymentStatus = 'Due';
        if (payToClowee > 0) {
          if (totalPaid >= payToClowee) {
            paymentStatus = 'Paid';
          } else if (totalPaid > 0) {
            paymentStatus = 'Partial';
          }
        } else if (totalPaid > 0) {
          // If no pay_to_clowee amount but has payments, mark as paid
          paymentStatus = 'Paid';
        }
        

        
        return {
          ...sale,
          invoice_number: invoiceNumber,
          machines: machine,
          franchises: franchise,
          total_paid: totalPaid,
          clowee_share_amount: sale.clowee_profit || 0,
          payment_status: paymentStatus,
          created_by_user: sale.created_by ? userMap.get(sale.created_by) : { name: 'System' },
        };
      });

      return salesWithDetails;
    },
  });
}

export function useCreateSale() {
  const queryClient = useQueryClient();
  const { notifyCreate } = useNotificationMutations();

  return useMutation({
    mutationFn: async (data: Omit<Sale, 'id' | 'created_at'>) => {
      const storedUser = sessionStorage.getItem('clowee_user');
      const userId = storedUser ? JSON.parse(storedUser).user.id : null;
      const insertData = userId ? { ...data, payment_status: 'Due', created_by: userId } : { ...data, payment_status: 'Due' };
      
      const { data: result, error } = await db
        .from("sales")
        .insert(insertData)
        .select()
        .single();
      
      if (error) throw new Error(error);
      return result;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["sales"] });
      toast.success("Sales record added successfully");
      notifyCreate("Sales", "record");
    },
    onError: (error: any) => {
      console.error("Error creating sale:", error);
      console.error("Error details:", error.message, error.details);
      toast.error(`Failed to add sales record: ${error.message || 'Unknown error'}`);
    },
  });
}

export function useUpdateSale() {
  const queryClient = useQueryClient();
  const { notifyUpdate } = useNotificationMutations();

  return useMutation({
    mutationFn: async ({ id, ...data }: { id: string } & Partial<Sale>) => {
      const { data: result, error } = await db
        .from("sales")
        .update(data)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return result;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["sales"] });
      toast.success("Sales data updated successfully");
      notifyUpdate("Sales", "record");
    },
    onError: (error) => {
      console.error("Error updating sale:", error);
      toast.error("Failed to update sales data");
    },
  });
}

export function useDeleteSale() {
  const queryClient = useQueryClient();
  const { notifyDelete } = useNotificationMutations();

  return useMutation({
    mutationFn: async (id: string) => {
      await db
        .from("sales")
        .delete()
        .eq("id", id)
        .execute();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["sales"] });
      toast.success("Sales data deleted successfully");
      notifyDelete("Sales", "record");
    },
    onError: (error) => {
      console.error("Error deleting sale:", error);
      toast.error("Failed to delete sales data");
    },
  });
}


